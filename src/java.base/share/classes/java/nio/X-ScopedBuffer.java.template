/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

#warn This file is preprocessed before being compiled

package java.nio;

import java.io.IOException;
import java.util.stream.IntStream;
import jdk.internal.foreign.MemorySegmentImpl;
import jdk.internal.ref.Cleaner;
import sun.nio.ch.DirectBuffer;

import java.foreign.MemorySegment;

class Scoped$Type$Buffer extends $Type$Buffer {

    final MemorySegment scope;
    final $Type$Buffer _buffer;

    Scoped$Type$Buffer(MemorySegment scope, $Type$Buffer _buffer) {
        super(_buffer.hb, _buffer.address, _buffer.capacity());
        this.scope = scope;
        this._buffer = _buffer;
    }
    
    void checkAlive() {
        ((MemorySegmentImpl)scope).checkValidState();
    }

    @Override
    public $Type$Buffer slice() {
        checkAlive();
        return of(scope, _buffer.slice());
    }

    @Override
    public $Type$Buffer slice(int index, int length) {
        checkAlive();
        return of(scope, _buffer.slice(index, length));
    }

    @Override
    public $Type$Buffer duplicate() {
        checkAlive();
        return of(scope, _buffer.duplicate());
    }

    @Override
    public $Type$Buffer asReadOnlyBuffer() {
        checkAlive();
        $Type$Buffer ro = _buffer.asReadOnlyBuffer();
        if (ro == _buffer) {
            return this;
        }
        return of(scope, _buffer.asReadOnlyBuffer());
    }

    @Override
    public $type$ get() {
        checkAlive();
        return _buffer.get();
    }

    @Override
    public $Type$Buffer put($type$ b) {
        checkAlive();
        _buffer.put(b);
        return this;
    }

    @Override
    public $type$ get(int index) {
        checkAlive();
        return _buffer.get(index);
    }

    @Override
    public $Type$Buffer put(int index, $type$ b) {
        checkAlive();
        _buffer.put(index, b);
        return this;
    }

    @Override
    public $Type$Buffer get($type$[] dst, int offset, int length) {
        checkAlive();
        return _buffer.get(dst, offset, length);
    }

    @Override
    public $Type$Buffer get($type$[] dst) {
        checkAlive();
        return _buffer.get(dst);
    }

    @Override
    public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
        checkAlive();
        return _buffer.get(index, dst, offset, length);
    }

    @Override
    public $Type$Buffer get(int index, $type$[] dst) {
        checkAlive();
        return _buffer.get(index, dst);
    }

    @Override
    public $Type$Buffer put($Type$Buffer src) {
        checkAlive();
        _buffer.put(src);
        return this;
    }

    @Override
    public $Type$Buffer put($type$[] src, int offset, int length) {
        checkAlive();
        _buffer.put(src, offset, length);
        return this;
    }

    @Override
    public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
        checkAlive();
        _buffer.put(index, src, offset, length);
        return this;
    }

    @Override
    public $Type$Buffer put(int index, $type$[] src) {
        checkAlive();
        _buffer.put(index, src);
        return this;
    }

    @Override
    public $Type$Buffer position(int newPosition) {
        checkAlive();
        _buffer.position(newPosition);
        return this;
    }

    @Override
    public $Type$Buffer limit(int newLimit) {
        checkAlive();
        _buffer.limit(newLimit);
        return this;
    }

    @Override
    public int position() {
        checkAlive();
        return _buffer.position();
    }

    @Override
    public int limit() {
        checkAlive();
        return _buffer.limit();
    }

    @Override
    public int capacity() {
        checkAlive();
        return _buffer.capacity();
    }

    @Override
    public int remaining() {
        checkAlive();
        return _buffer.remaining();
    }

    @Override
    public boolean hasRemaining() {
        checkAlive();
        return _buffer.hasRemaining();
    }

    @Override
    public $Type$Buffer mark() {
        checkAlive();
        _buffer.mark();
        return this;
    }

    @Override
    public $Type$Buffer reset() {
        checkAlive();
        _buffer.reset();
        return this;
    }

    @Override
    public $Type$Buffer clear() {
        checkAlive();
        _buffer.clear();
        return this;
    }

    @Override
    public $Type$Buffer flip() {
        checkAlive();
        _buffer.flip();
        return this;
    }

    @Override
    public $Type$Buffer rewind() {
        checkAlive();
        _buffer.rewind();
        return this;
    }

    @Override
    public $Type$Buffer compact() {
        checkAlive();
        _buffer.compact();
        return this;
    }

    @Override
    public boolean isDirect() {
        checkAlive();
        return _buffer.isDirect();
    }

    @Override
    public String toString() {
        checkAlive();
        return _buffer.toString();
    }

    @Override
    public int hashCode() {
        checkAlive();
        return _buffer.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        checkAlive();
        return _buffer.equals(o);
    }

    @Override
    public int compareTo($Type$Buffer that) {
        checkAlive();
        return _buffer.compareTo(that);
    }

    @Override
    public int mismatch($Type$Buffer that) {
        checkAlive();
        return _buffer.mismatch(that);
    }

    @Override
    public boolean isReadOnly() {
        checkAlive();
        return _buffer.isReadOnly();
    }

    @Override
    Object base() {
        checkAlive();
        return _buffer.base();
    }

    @Override
    public $Type$Buffer put($type$[] src) {
        checkAlive();
        _buffer.put(src);
        return this;
    }

    @Override
    public boolean hasArray() {
        checkAlive();
        return super.hasArray();
    }

    @Override
    public $type$[] array() {
        checkAlive();
        return super.array();
    }

    @Override
    public int arrayOffset() {
        checkAlive();
        return super.arrayOffset();
    }

    @Override
    public ByteOrder order() {
        checkAlive();
        return _buffer.order();
    }

#if[byte]
    @Override
    public $Type$Buffer order(ByteOrder bo) {
        checkAlive();
        return of(scope, _buffer.order(bo));
    }

    @Override
    public int alignmentOffset(int index, int unitSize) {
        checkAlive();
        return _buffer.alignmentOffset(index, unitSize);
    }

    @Override
    public $Type$Buffer alignedSlice(int unitSize) {
        checkAlive();
        return of(scope, _buffer.alignedSlice(unitSize));
    }

#end[byte]

#if[streamableType]
    $type$ getUnchecked(int index) {
        return _buffer.getUnchecked(index);
    }
#end[streamableType]

#if[char]
    @Override
    public int read(CharBuffer target) throws IOException {
        checkAlive();
        return _buffer.read(target);
    }

    @Override
    public $Type$Buffer put(String src, int start, int end) {
        checkAlive();
        return of(scope, _buffer.put(src, start, end));
    }

    @Override
    public $Type$Buffer put(String src) {
        checkAlive();
        return of(scope, _buffer.put(src));
    }

    @Override
    String toString(int start, int end) {
        checkAlive();
        return _buffer.toString(start, end);
    }

    @Override
    public int length() {
        checkAlive();
        return _buffer.length();
    }

    @Override
    public char charAt(int index) {
        checkAlive();
        return _buffer.charAt(index);
    }

    @Override
    public CharBuffer subSequence(int start, int end) {
        checkAlive();
        return of(scope, _buffer.subSequence(start, end));
    }

    @Override
    public $Type$Buffer append(CharSequence csq) {
        checkAlive();
        return of(scope, _buffer.append(csq));
    }

    @Override
    public $Type$Buffer append(CharSequence csq, int start, int end) {
        checkAlive();
        return of(scope, _buffer.append(csq, start, end));
    }

    @Override
    public $Type$Buffer append($type$ $x$) {
        checkAlive();
        return of(scope, _buffer.append($x$));
    }

    @Override
    ByteOrder charRegionOrder() {
        checkAlive();
        return _buffer.charRegionOrder();
    }

    @Override
    public IntStream chars() {
        checkAlive();
        return _buffer.chars();
    }

    @Override
    public IntStream codePoints() {
        checkAlive();
        return _buffer.codePoints();
    }
#end[char]

    static class ScopedDirect$Type$Buffer extends Scoped$Type$Buffer implements DirectBuffer {
        ScopedDirect$Type$Buffer(MemorySegment scope, $Type$Buffer _buffer) {
            super(scope, _buffer);
        }

        @Override
        public long address() {
            return ((DirectBuffer)_buffer).address();
        }

        @Override
        public Object attachment() {
            return ((DirectBuffer)_buffer).attachment();
        }

        @Override
        public Cleaner cleaner() {
            return ((DirectBuffer)_buffer).cleaner();
        }
    }
    
    public static Scoped$Type$Buffer of(MemorySegment scope, $Type$Buffer bb) {
        if (bb.isDirect()) {
            return new ScopedDirect$Type$Buffer(scope, bb);
        } else {
            return new Scoped$Type$Buffer(scope, bb);
        }
    }

#if[byte]
    // #BIN
    //
    // Binary-data access methods  for short, char, int, long, float,
    // and double will be inserted here

#end[byte]

}
