/*
 * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

import java.foreign.annotations.NativeAddressof;
import java.foreign.annotations.NativeGetter;
import java.foreign.annotations.NativeHeader;
import java.foreign.annotations.NativeLocation;
import java.foreign.annotations.NativeSetter;
import java.foreign.annotations.NativeStruct;
import java.foreign.memory.Pointer;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.spi.ToolProvider;
import org.testng.annotations.Test;
import static org.testng.Assert.assertTrue;

/*
 * @test
 * @bug 8221154 8221228 8221336 8221419 8221443 8222274
 * @summary jextract should generate java source files
 * @library ..
 * @run testng SrcGenTest
 */
public class SrcGenTest extends JextractToolRunner {
    private static final ToolProvider JEXTRACT = ToolProvider.findFirst("jextract")
            .orElseThrow(() ->
                    new RuntimeException("jextract tool not found")
            );

    private static final ToolProvider JAVAC = ToolProvider.findFirst("javac")
            .orElseThrow(() ->
                    new RuntimeException("javac tool not found")
            );

    @Test
    public void test() throws IOException {
        Path inputDir = Paths.get(System.getProperty("test.src", "."));
        Path outputDir = Paths.get(System.getProperty("test.classes", "."));
        inputDir = inputDir.toAbsolutePath();
        outputDir = outputDir.toAbsolutePath();
        String pkgName = "test8221154";
        Path jarPath = outputDir.resolve(pkgName + ".jar");

        // run jextract with --src-dump-dir option
        ArrayList<String> jextrOpts = new ArrayList<>();
        jextrOpts.add("-C-nostdinc");
        jextrOpts.add("-I");
        jextrOpts.add(inputDir.toString());
        jextrOpts.add("-o");
        jextrOpts.add(jarPath.toString());
        jextrOpts.add("--src-dump-dir");
        jextrOpts.add(outputDir.toString());
        jextrOpts.add("-t");
        jextrOpts.add(pkgName);
        jextrOpts.add("-l");
        jextrOpts.add("srcgentest");
        jextrOpts.add(inputDir + File.separator + "srcgentest.h");

        int result = JEXTRACT.run(System.out, System.err, jextrOpts.toArray(String[]::new));
        if (result != 0) {
            throw new RuntimeException(JEXTRACT.name() + " returns non-zero value");
        }

        // delete .jar file generated by jextract
        Files.delete(jarPath);

        Path pkgDir = outputDir.resolve(pkgName);

        String srcgentestIfaceName = headerInterfaceName("srcgentest.h");
        String srcgentestForwarderName = staticForwarderName("srcgentest.h");
        String dupnameIfaceName = headerInterfaceName("dupname.h");
        String dupnameDupnameNotName = structInterfaceName("dupname.h", "dupnameNot");
        String dupnameForwarderName = staticForwarderName("dupname.h");
        String srcgentestPointName = structInterfaceName("srcgentest.h", "Point");
        String srcgentestColorName = enumInterfaceName("srcgentest.h", "Color");
        String srcgentestForwarderEnumName = enumForwarderInterfaceName("srcgentest.h", "Color");

        // compile jextract generated java sources
        ArrayList<String> javacOpts = new ArrayList<>();
        javacOpts.add("-d");
        javacOpts.add(outputDir.toString());
        javacOpts.add(outputDir.resolve("clang_support").resolve("stdbool_h.java").toString());
        javacOpts.add(pkgDir.resolve(srcgentestIfaceName + ".java").toString());
        javacOpts.add(pkgDir.resolve(srcgentestForwarderName + ".java").toString());
        javacOpts.add(pkgDir.resolve("sub").resolve(dupnameIfaceName + ".java").toString());
        javacOpts.add(pkgDir.resolve("sub").resolve(dupnameForwarderName + ".java").toString());
        result = JAVAC.run(System.out, System.err, javacOpts.toArray(String[]::new));
        if (result != 0) {
            throw new RuntimeException(JAVAC.name() + " returns non-zero value");
        }

        // sanity checks for .class file existence
        assertTrue(Files.isRegularFile(outputDir.resolve("clang_support").resolve("stdbool_h.class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve(srcgentestIfaceName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve(srcgentestPointName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve(srcgentestColorName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve(srcgentestForwarderName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve(srcgentestForwarderEnumName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve("sub").resolve(dupnameForwarderName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve("sub").resolve(dupnameIfaceName + ".class")));
        assertTrue(Files.isRegularFile(pkgDir.resolve("sub").resolve(dupnameDupnameNotName + ".class")));

        checkClasses(outputDir, pkgName);
    }

    private void checkClasses(Path outputDir, String pkgName) {
        Loader loader = classLoader(outputDir);
        checkSubdirClass(loader, pkgName);
        checkHeaderClass(loader, pkgName);
        checkForwarderClass(loader, pkgName);
    }

    private void checkSubdirClass(Loader loader, String pkgName) {
        Class<?> dupname = loader.loadClass(pkgName + ".sub." + headerInterfaceName("dupname.h"));
        assertTrue(dupname != null);
    }

    private void checkHeaderClass(Loader loader, String pkgName) {
        Class<?> headerCls = loader.loadClass(pkgName + "." + headerInterfaceName("srcgentest.h"));
        assertTrue(headerCls != null);
        assertTrue(headerCls.getAnnotation(NativeHeader.class) != null);

        // global 'num' getter, pointer getter
        Method numGetter = findGlobalVariableGet(headerCls, "num");
        assertTrue(numGetter != null);
        assertTrue(numGetter.getAnnotation(NativeGetter.class) != null);
        assertTrue(numGetter.getAnnotation(NativeLocation.class) != null);

        Method numPtrGetter = findGlobalVariablePointerGet(headerCls, "num");
        assertTrue(numPtrGetter != null);
        assertTrue(numPtrGetter.getAnnotation(NativeAddressof.class) != null);

        // global 'num' setter
        Method numSetter = findGlobalVariableSet(headerCls, "num", int.class);
        assertTrue(numSetter != null);
        assertTrue(numSetter.getAnnotation(NativeSetter.class) != null);

        // check "x_coord" method
        Method xCoordMethod = findFirstMethod(headerCls, "x_coord");
        assertTrue(xCoordMethod.getReturnType() == int.class);
        Class<?>[] xCoordParamTypes = xCoordMethod.getParameterTypes();
        assertTrue(xCoordParamTypes.length == 1);
        assertTrue(xCoordParamTypes[0] == Pointer.class);
        assertTrue(xCoordMethod.getAnnotation(NativeLocation.class) != null);
        assertTrue(!Modifier.isStatic(xCoordMethod.getModifiers()));

        // check "y_coord" method
        Method yCoordMethod = findFirstMethod(headerCls, "y_coord");
        assertTrue(yCoordMethod.getReturnType() == int.class);
        Class<?>[] yCoordParamTypes = yCoordMethod.getParameterTypes();
        assertTrue(yCoordParamTypes.length == 1);
        assertTrue(yCoordParamTypes[0] == Pointer.class);
        assertTrue(yCoordMethod.getAnnotation(NativeLocation.class) != null);
        assertTrue(!Modifier.isStatic(yCoordMethod.getModifiers()));

        // check "sum" method
        Method sumMethod = findFirstMethod(headerCls, "sum");
        assertTrue(sumMethod.getReturnType() == int.class);
        Class<?>[] sumParamTypes = sumMethod.getParameterTypes();
        assertTrue(sumParamTypes.length == 2);
        assertTrue(sumParamTypes[0] == int.class);
        assertTrue(sumParamTypes[1] == Object[].class);
        assertTrue(sumMethod.getAnnotation(NativeLocation.class) != null);
        assertTrue(!Modifier.isStatic(sumMethod.getModifiers()));

        // struct Point
        Class<?> pointCls = Arrays.stream(headerCls.getClasses())
            .filter(c -> c.getSimpleName().equals("Point")).findFirst().get();
        assertTrue(Modifier.isInterface(pointCls.getModifiers()));
        assertTrue(pointCls.getAnnotation(NativeStruct.class) != null);
        assertTrue(pointCls.getAnnotation(NativeLocation.class) != null);

        // Point extends Struct
        Class<?> pointSuper = pointCls.getInterfaces()[0];
        assertTrue(pointSuper.getName().equals("java.foreign.memory.Struct"));

        // x, y getters, pointer getters
        Method xGetter = findStructFieldGet(pointCls, "x");
        assertTrue(xGetter != null);
        assertTrue(xGetter.getAnnotation(NativeGetter.class) != null);
        assertTrue(xGetter.getAnnotation(NativeLocation.class) != null);

        Method yGetter = findStructFieldGet(pointCls, "y");
        assertTrue(yGetter != null);
        assertTrue(yGetter.getAnnotation(NativeGetter.class) != null);
        assertTrue(yGetter.getAnnotation(NativeLocation.class) != null);

        Method xPtrGetter = findStructFieldPointerGet(pointCls, "x");
        assertTrue(xPtrGetter != null);
        assertTrue(xPtrGetter.getAnnotation(NativeAddressof.class) != null);

        Method yPtrGetter = findStructFieldPointerGet(pointCls, "y");
        assertTrue(yPtrGetter != null);
        assertTrue(yPtrGetter.getAnnotation(NativeAddressof.class) != null);

        // x, y setters
        Method xSetter = findStructFieldSet(pointCls, "x", int.class);
        assertTrue(xSetter != null);
        assertTrue(xSetter.getAnnotation(NativeSetter.class) != null);

        Method ySetter = findStructFieldSet(pointCls, "y", int.class);
        assertTrue(ySetter != null);
        assertTrue(ySetter.getAnnotation(NativeSetter.class) != null);
    }

    private void checkForwarderClass(Loader loader, String pkgName) {
        Class<?> forwarderCls = loader.loadClass(pkgName + "." + staticForwarderName("srcgentest.h"));
        assertTrue(forwarderCls != null);

        // check "sum" method
        Method sumMethod = findFirstMethod(forwarderCls, "sum");
        assertTrue(sumMethod.getReturnType() == int.class);
        Class<?>[] sumParamTypes = sumMethod.getParameterTypes();
        assertTrue(sumParamTypes.length == 2);
        assertTrue(sumParamTypes[0] == int.class);
        assertTrue(sumParamTypes[1] == Object[].class);
        assertTrue(Modifier.isStatic(sumMethod.getModifiers()));

        // check "x_coord" method
        Method xCoordMethod = findFirstMethod(forwarderCls, "x_coord");
        assertTrue(xCoordMethod.getReturnType() == int.class);
        Class<?>[] xCoordParamTypes = xCoordMethod.getParameterTypes();
        assertTrue(xCoordParamTypes.length == 1);
        assertTrue(xCoordParamTypes[0] == Pointer.class);
        assertTrue(Modifier.isStatic(xCoordMethod.getModifiers()));

        // check "y_coord" method
        Method yCoordMethod = findFirstMethod(forwarderCls, "y_coord");
        assertTrue(yCoordMethod.getReturnType() == int.class);
        Class<?>[] yCoordParamTypes = yCoordMethod.getParameterTypes();
        assertTrue(yCoordParamTypes.length == 1);
        assertTrue(yCoordParamTypes[0] == Pointer.class);
        assertTrue(Modifier.isStatic(xCoordMethod.getModifiers()));

        // global variable "num" getter
        Method numGet = findGlobalVariableGet(forwarderCls, "num");
        assertTrue(numGet != null);

        // anonymous enum fields
        assertTrue(findField(forwarderCls, "R") != null);
        assertTrue(findField(forwarderCls, "G") != null);
        assertTrue(findField(forwarderCls, "B") != null);

        // enum interface class
        Class<?> colorCls = Arrays.stream(forwarderCls.getClasses())
            .filter(c -> c.getSimpleName().equals("Color")).findFirst().get();
        assertTrue(Modifier.isInterface(colorCls.getModifiers()));
        checkIntField(colorCls, "RED", 0);
        checkIntField(colorCls, "GREEN", 1);
        checkIntField(colorCls, "BLUE", 2);
    }
}
